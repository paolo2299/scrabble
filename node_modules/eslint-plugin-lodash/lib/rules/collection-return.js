/**
 * @fileoverview Rule to check that iteratees for all collection functions except forEach return a value;
 */
'use strict';

/**
 * @fileoverview Rule to check that iteratees for all collection functions except forEach return a value;
 */
//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
    create: function create(context) {
        var _require = require('../util/lodashUtil');

        var getLodashMethodCallExpVisitor = _require.getLodashMethodCallExpVisitor;
        var getLodashContext = _require.getLodashContext;

        var _require2 = require('../util/methodDataUtil');

        var getCollectionMethods = _require2.getCollectionMethods;

        var _require3 = require('../util/astUtil');

        var isFunctionDefinitionWithBlock = _require3.isFunctionDefinitionWithBlock;

        var assign = require('lodash/assign');
        var collectionMethods = void 0;
        var funcInfos = new Map();
        var currFuncInfo = {};
        var lodashContext = getLodashContext(context);
        return assign({
            'CallExpression:exit': getLodashMethodCallExpVisitor(lodashContext, function (node, iteratee, _ref) {
                var method = _ref.method;
                var version = _ref.version;

                collectionMethods = collectionMethods || new Set(getCollectionMethods(version));
                if (collectionMethods.has(method) && funcInfos.has(iteratee)) {
                    var _funcInfos$get = funcInfos.get(iteratee);

                    var hasReturn = _funcInfos$get.hasReturn;

                    if (isFunctionDefinitionWithBlock(iteratee) && !hasReturn) {
                        context.report(node, 'Do not use _.' + method + ' without returning a value');
                    }
                }
            }),
            ReturnStatement: function ReturnStatement() {
                currFuncInfo.hasReturn = true;
            },
            onCodePathStart: function onCodePathStart(codePath, node) {
                currFuncInfo = {
                    upper: currFuncInfo,
                    codePath: codePath,
                    hasReturn: false
                };
                funcInfos.set(node, currFuncInfo);
            },
            onCodePathEnd: function onCodePathEnd() {
                currFuncInfo = currFuncInfo.upper;
            }
        }, lodashContext.getImportVisitors());
    }
};